<?php

namespace Drush\Commands\core;

use Drush\Commands\DrushCommands;
use Drush\Drush;
use Drush\Exceptions\UserAbortException;
use Drush\Utils\FsUtils;
use Exception;
use PharData;
use Symfony\Component\Filesystem\Exception\IOException;
use Symfony\Component\Filesystem\Filesystem;
use Webmozart\PathUtil\Path;

/**
 * Class ArchiveRestoreCommands.
 */
class ArchiveRestoreCommands extends DrushCommands
{
    /**
     * @var \Symfony\Component\Filesystem\Filesystem
     */
    private Filesystem $filesystem;

    /**
     * @var string
     */
    private string $extractedPath;

    private const COMPONENT_CODE = 'code';

    private const COMPONENT_FILES = 'files';

    private const COMPONENT_DATABASE = 'database';
    private const SQL_DUMP_FILE_NAME = 'database.sql';

    private const TEMP_DIR_NAME = 'uncompressed';

    /**
     * Restore (import) your code, files, and database.
     *
     * @command archive:restore
     * @aliases arr
     *
     * @option code Import code.
     * @option code_path Import code from specified directory. Has higher priority over "path" argument.
     * @option db Import database.
     * @option db_path Import database from specified dump file. Has higher priority over "path" argument.
     * @option files Import Drupal files.
     * @option files_path Import Drupal files from specified directory. Has higher priority over "path" argument.
     * @option overwrite Overwrite files if exists when un-compressing an archive.
     *
     * @optionset_sql
     * @optionset_table_selection
     *
     * @bootstrap max configuration
     *
     * @param string|null $path
     *   The full path to a single archive file (*.tar.gz) or a directory with components to import.
     *   May contain the following components generated by `archive:dump` command:
     *   1) code ("code" directory);
     *   2) database dump file ("database/database.sql" file);
     *   3) Drupal files ("files" directory).
     * @param array $options
     *
     * @throws \Exception
     */
    public function restore(
        string $path = null,
        array  $options = [
            'code' => false,
            'code_path' => null,
            'db' => false,
            'db_path' => null,
            'files' => false,
            'files_path' => null,
            'overwrite' => false,
        ]): void
    {
        $this->prepareTempDir();

        $extractDir = null;
        if (null !== $path) {
            $extractDir = is_dir($path) ? $path : $this->extractArchive($path, $options);
        }

        if (!$options['code'] && !$options['files'] && !$options['db']) {
            $options['code'] = $options['files'] = $options['db'] = true;
        }

        foreach (['code' => 'code', 'db' => 'database', 'files' => 'files'] as $component => $label) {
            if (!$options[$component]) {
                continue;
            }

            // Validate requested components have sources.
            if (null === $extractDir && null === $options[$component . '_path']) {
                throw new Exception(
                    dt('Missing either "path" input or "!component_path" option for the !label component.',
                        [
                            '!component' => $component,
                            '!label' => $label,
                        ]
                    )
                );
            }
        }

        if ($options['code']) {
            $codeComponentPath = $options['code_path'] ?? Path::join($extractDir, self::COMPONENT_CODE);
            $this->importCode($codeComponentPath);
        }

        if ($options['db']) {
            $databaseComponentPath = $options['db_path'] ?? Path::join($extractDir, self::COMPONENT_DATABASE, self::SQL_DUMP_FILE_NAME);
            $this->importDatabase($databaseComponentPath);
        }

        if ($options['files']) {
            $filesComponentPath = $options['files_path'] ?? Path::join($extractDir, self::COMPONENT_FILES);
            $this->importFiles($filesComponentPath);
        }

        $this->logger()->info(dt('Done!'));
    }

    /**
     * Creates a temporary directory to extract the archive onto.
     *
     * @throws \Exception
     */
    protected function prepareTempDir(): void
    {
        $this->filesystem = new Filesystem();
        $this->extractedPath = FsUtils::prepareBackupDir(self::TEMP_DIR_NAME);
        register_shutdown_function([$this, 'cleanUp']);
    }

    /**
     * Extracts the archive.
     *
     * @param string $path
     *   The path to the archive file.
     * @param array $options
     *   Command options.
     *
     * @return string
     *
     * @throws \Exception
     */
    protected function extractArchive(string $path, array $options): string
    {
        $this->logger()->info('Extracting the archive...');

        if (!is_file($path)) {
            // @todo: use dt() instead of sprintf().
            throw new Exception(sprintf('File %s is not found.', $path));
        }

        if (!preg_match('/\.tar\.gz$/', $path)) {
            throw new Exception(sprintf('File %s is not a *.tar.gz file.', $path));
        }

        ['filename' => $archiveFileName] = pathinfo($path);
        $archiveFileName = str_replace('.tar', '', $archiveFileName);

        $extractDir = Path::join(dirname($path), $archiveFileName);
        if (is_dir($extractDir)) {
            if ($options['overwrite']) {
                $this->filesystem->remove($extractDir);
            } else {
                throw new Exception(
                    dt('Extract directory !path already exists (use "--overwrite" option).', ['!path' => $extractDir])
                );
            }
        }

        $this->filesystem->mkdir($extractDir);

        $archive = new PharData($path);
        $archive->extractTo($extractDir);

        $this->logger()->info(dt('The archive successfully extracted into !path', ['!path' => $extractDir]));

        return $extractDir;
    }

    /**
     * Imports the code to the site.
     *
     * @param string $codePath
     *   The path to the code files directory.
     *
     * @throws \Drush\Exceptions\UserAbortException
     * @throws \Exception
     */
    protected function importCode(string $codePath): void
    {
        $this->logger()->info('Importing code...');

        if (!is_dir($codePath)) {
            throw new Exception(dt('Directory !path not found.', ['!path' => $codePath]));
        }

        if (!$this->io()->confirm(dt('Are you sure you want to import the code?')))
        {
            throw new UserAbortException();
        }

        $source = $codePath . DIRECTORY_SEPARATOR;
        $this->logger()->info(sprintf('Source: %s', $source));

        $bootstrapManager = Drush::bootstrapManager();
        $destination = rtrim($bootstrapManager->getComposerRoot(), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
        $this->logger()->info(sprintf('Destination: %s', $destination));

//        $parameters = [];
//        $parameters[] = Escape::shellArg($source);
//
//        $aliasConfigContext = $this->getConfig()->getContext(ConfigLocator::ALIAS_CONTEXT);
//        $manager = $this->siteAliasManager();
//        $aliasName = $this->siteAliasManager()->getSelf()->name();
//        $evaluatedPath = HostPath::create($manager, $aliasName);
//
//        $pathEvaluator = new BackendPathEvaluator();
//        $pathEvaluator->evaluate($evaluatedPath);
//
//        $aliasRecord = $evaluatedPath->getSiteAlias();
//        if ($aliasRecord->isRemote()) {
//            $aliasConfigContext->combine($aliasRecord->export());
//        }
//
//        $destination = $evaluatedPath->fullyQualifiedPath() . DIRECTORY_SEPARATOR;

        $ssh_options = $this->getConfig()->get('ssh.options', '');
        $exec = "rsync -e 'ssh $ssh_options'" . ' -akz ' . $source . ' ' . $destination;

        $process = $this->processManager()->shell($exec);
        $process->mustRun();

        if (!$process->isSuccessful()) {
            throw new Exception(
                dt("Could not rsync from !source to !dest",
                    [
                        '!source' => $source,
                        '!dest' => $destination,
                    ]
                )
            );
        }
    }

    /**
     * Imports the database dump to the site.
     *
     * @param string $databaseDumpPath
     *   The path to the database dump file.
     *
     * @throws \Drush\Exceptions\UserAbortException
     * @throws \Exception
     */
    protected function importDatabase(string $databaseDumpPath): void
    {
        $this->logger()->info('Importing database...');

        if (!is_file($databaseDumpPath)) {
            throw new Exception(dt('Database dump file !path not found.', ['!path' => $databaseDumpPath]));
        }

        if (!$this->io()->confirm(dt('Are you sure you want to import the database dump?')))
        {
            throw new UserAbortException();
        }
    }

    /**
     * Imports Drupal files to the site.
     *
     * @param string $filesPath
     *   The path to the Drupal files directory.
     *
     * @throws \Drush\Exceptions\UserAbortException
     * @throws \Exception
     */
    protected function importFiles(string $filesPath): void
    {
        $this->logger()->info('Importing files...');

        if (!is_dir($filesPath)) {
            throw new Exception(dt('Directory !path not found.', ['!path' => $filesPath]));
        }

        if (!$this->io()->confirm(dt('Are you sure you want to import the Drupal files?')))
        {
            throw new UserAbortException();
        }
    }

    /**
     * Performs clean-up tasks.
     *
     * Deletes temporary directory.
     */
    public function cleanUp(): void
    {
        try {
            $this->logger()->info(dt('Deleting !path...', ['!path' => $this->extractedPath]));
            $this->filesystem->remove($this->extractedPath);
        } catch (IOException $e) {
            $this->logger()->info(
                dt(
                    'Failed deleting !path: !message',
                    ['!path' => $this->extractedPath, '!message' => $e->getMessage()]
                )
            );
        }
    }
}
